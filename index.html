<!DOCTYPE html>
<html>
  <head>
    <title>Deerfield Watershed Road-Stream Crossing Explorer</title>
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" />
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
    <link rel="stylesheet" href="http://colorbrewer2.org/export/colorbrewer.css" />
    <link rel="stylesheet" href="styles/Control.BingGeocoder.css" />
    <link rel="stylesheet" href="styles/Control.maxExtent.css" />
    <link rel="stylesheet" href="styles/app.css" />
    <link rel="stylesheet" href="styles/deerfield_crossings.css" />

    <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>
    <script src="http://maps.google.com/maps/api/js?v=3.2&sensor=false"></script>
    <script src="Bing_tile.js"></script>
    <script src="Google_tile.js"></script>
    <script src="Control.BingGeocoder.js"></script>
    <script src="Control.maxExtent.js"></script>

    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="http://colorbrewer2.org/export/colorbrewer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min.js"></script>
    <script src="crossfilter.min.js"></script>

  </head>

  <body>
    <div id="map"></div>

    <script type='text/javascript'>
      //******Add Map
      var map = new L.Map('map', {center: new L.LatLng(42.74, -72.83), zoomControl: false, zoom: 10, minZoom: 2, maxZoom: 20, inertiaDeceleration: 1000});

      //******Add map controls
      L.control.scale({ maxWidth: 200 }).addTo(map);
      L.control.zoom({ position: 'topleft', zoomInText: '+', zoomOutText: '-' }).addTo(map);
      var maxExtent = new L.Control.maxExtent();
      map.addControl(maxExtent);

      //******Bing geocoder control
      var tmpPoint = new L.marker;
      var bingGeocoder = new L.Control.BingGeocoder('At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn', { callback: function (results) {
                     var bbox = results.resourceSets[0].resources[0].bbox,
                            first = new L.LatLng(bbox[0], bbox[1]),
                            second = new L.LatLng(bbox[2], bbox[3]),
                            tmpBounds = new L.LatLngBounds([first, second]);
                     this._map.fitBounds(tmpBounds);
                     this._map.removeLayer(tmpPoint);
                     tmpPoint = new L.marker(results.resourceSets[0].resources[0].point.coordinates).bindPopup(results.resourceSets[0].resources[0].address.formattedAddress);
                     this._map.addLayer(tmpPoint);
                   }
      });

      map.addControl(bingGeocoder);

      //******Add basemaps
      var googleHybrid = new L.Google('HYBRID');
      var googleSatellite = new L.Google('SATELLITE');
      var googleStreet = new L.Google('ROADMAP');
      var googleTerrain = new L.Google('TERRAIN');
      var bingHybrid = new L.BingLayer("At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn", {type: 'AerialWithLabels'});
      var bingSatellite = new L.BingLayer("At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn", {type: 'Aerial'});
      var bingStreet = new L.BingLayer("At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn", {type: 'Road'});

      map.addLayer(googleHybrid);

      //******Add Geoserver Layers
      var gsHuc8 = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/crossings/wms", {
        layers: 'crossings:deerfield_huc8',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsTowns = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/crossings/wms", {
        layers: 'crossings:deerfield_towns',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsCounties = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/crossings/wms", {
        layers: 'crossings:deerfield_counties',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsDOTDistricts = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/crossings/wms", {
        layers: 'crossings:deerfield_dot_districts',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });


      //******Make d3 vector layers variable
      var topoSVG = d3.select(map.getPanes().overlayPane).append("svg");
      var catchG = topoSVG.append("g").attr("class", "leaflet-zoom-hide").attr("id", "catchG");
      var streamG = topoSVG.append("g").attr("class", "leaflet-zoom-hide").attr("id", "streamG");
      var crossG = topoSVG.append("g").attr("class", "leaflet-zoom-hide").attr("id", "crossG");

      //******Make dummy layer variables for layer controller
      var crossTogSVG = d3.select(map.getPanes().overlayPane).append("svg");

      crossTogSVG.onAdd = function(map) {
        //******Add Deerfield road/stream crossings
        var tmpFeats = crossG.selectAll(".crossings")
            .data(crossings.features)
          .enter().append("path")
            .attr("d", path)
            .attr("class", "crossings")
            .on("mouseover", function(data) { showIt(this.id); })
            .on("mousemove", function() { return tooltip.style("top", (d3.event.pageY-10) + "px").style("left", (d3.event.pageX+10) + "px"); })
            .on("mouseout", function() { return tooltip.style("visibility", "hidden"); });
        changeStyle(d3.select("#crossingsSelect").node().value, crossG, "crossings", crossings);
        d3.select("#crossingsLegend").style("display", "block");
      }

      crossTogSVG.onRemove = function(map) {
        var tmpFeats = crossG.selectAll(".crossings");
        tmpFeats.remove();
        d3.select("#crossingsLegend").style("display", "none");
      }

      var streamTogSVG = d3.select(map.getPanes().overlayPane).append("svg");
      //var streamTogG = streamTogSVG.append("g").attr("class", "leaflet-zoom-hide");
  
      streamTogSVG.onAdd = function(map) {
        //******Add Deerfield streams
        var tmpFeats = streamG.selectAll(".streams")
            .data(streams.features)
          .enter().insert("path", ":first-child")
            .attr("d", path)
            .attr("class", "streams")
            .attr("id", function(data) { return ("str_order: " + data.properties.str_order); })
            .style("stroke-width", function(data) { return (0.5 + (0.5 * data.properties.str_order) + "px") ; })
            .style("stroke", function(data) { return streamColor(10 - data.properties.str_order); })
            .on("mouseover", function(data) { showIt(this.id); })
            .on("mousemove", function() { return tooltip.style("top", (d3.event.pageY-10) + "px").style("left", (d3.event.pageX+10) + "px"); })
            .on("mouseout", function() { return tooltip.style("visibility", "hidden"); });
       }

      streamTogSVG.onRemove = function(map) {
        var tmpFeats = streamG.selectAll(".streams");
        tmpFeats.remove();
      }

      var catchTogSVG = d3.select(map.getPanes().overlayPane).append("svg");
      //var catchTogG = catchTogSVG.append("g").attr("class", "leaflet-zoom-hide");

      catchTogSVG.onAdd = function(map) {
        //******Add Deerfield catchments
        var tmpFeats = catchG.selectAll(".catchments")
            .data(catchments.features)
          .enter().insert("path", ":first-child")
            .attr("d", path)
            .attr("class", "catchments")
            .on("mouseover", function(data) { showIt(this.id); })
            .on("mousemove", function() { return tooltip.style("top", (d3.event.pageY-10) + "px").style("left", (d3.event.pageX+10) + "px"); })
            .on("mouseout", function() { return tooltip.style("visibility", "hidden"); });
        changeStyle(d3.select("#catchmentsSelect").node().value, catchG, "catchments", catchments);
        d3.select("#catchmentsLegend").style("display", "block");
      }

      catchTogSVG.onRemove = function(map) {
        var tmpFeats = catchG.selectAll(".catchments");
        tmpFeats.remove();
        d3.select("#catchmentsLegend").style("display", "none");
      } 

      map.addLayer(gsHuc8);

      //******Make layer controller
      var baseLayers = {"Google Hybrid": googleHybrid, "Google Satellite": googleSatellite, "Google Street": googleStreet, "Google Terrain": googleTerrain, "Bing Hybrid": bingHybrid, "Bing Satellite": bingSatellite, "Bing Street": bingStreet};
      var overlays = {"DOT Districts": gsDOTDistricts, "Counties": gsCounties, "Towns": gsTowns, "Deerfield Watershed": gsHuc8, "Catchments": catchTogSVG, "Streams": streamTogSVG, "Crossings": crossTogSVG};
      L.control.layers(baseLayers, overlays).addTo(map);

/*
      //******Make header div
      d3.select("body")
        .append("div")
        .attr("class", "header");
*/

      //******Make tooltip for displaying attribute data
      var tooltip = d3.select("body")
        .append("div")
        .attr("class", "d3Tooltip");

      //******Make div for legend
      d3.select("body")
        .append("div")
        .attr("class", "legend")
        .attr("id", "legendDiv");

      d3.select("#legendDiv")
        .append("div")
        .attr("id", "crossingsLegend");

      d3.select("#crossingsLegend")
        .append("h4")
        .text("Crossing Attributes")
        .attr("class", "legTitle");

      d3.select("#legendDiv")
        .append("div")
        .attr("id", "catchmentsLegend")
        .style("display", "none");

      d3.select("#catchmentsLegend")
        .append("h4")
        .text("Catchment Attributes")
        .attr("class", "legTitle")
        .style("margin-top", "20px");

 

      //******Make divs for filter titles and selects
      d3.select("body")
        .append("div")
        .attr("class", "legend")
        .attr("id", "filters");

      d3.select("#filters")
        .append("h4")
        .text("Filters")
        .attr("class", "legTitle");

      d3.select("#filters")
        .append("div")
        .attr("id", "filterTitle");

      d3.select("#filters")
        .append("div")
        .attr("class", "legAttrSel")
        .attr("id", "filterSelect");

      //*******Add checkbox for linking crossfilters
      d3.select("#filters")
        .append("input")
        .attr({type: "checkbox", name: "cfLink", value: "linked"})
        .attr("id", "cfLink")
        .attr("checked", true)
        .style("margin", "9px");

      d3.select("#filters")
        .append("label")
        .text("Link Filters")
        .attr("id", "linkLabel");

      //*******Add div for histograms
      d3.select("#filters")
        .append("hr")
        .attr("class", "hr");

      d3.select("#filters")
        .append("div")
          .attr("id", "charts")
        .append("div")
          .attr("id", "totals");





      //******Make color scale for streams
      var streamColor = d3.scale.quantize()
        .domain([1, 9])
        .range(colorbrewer.YlGnBu[9]);






      //******Make variables for d3 topoJSON and TSV data
      var streams;  //global stream topojson variable
      var crossings;  //global crossings topojson variable
      var catchments;  //global catchments topojson variable
      var bounds;  //global bounds variable
      var path;    //global path variable
      var crossCov;   //global crossing covariate data variable
      var catchCov;   //global catchment covariate data variable
      var crossKeys;  //global crossing keys variable
      var catchKeys;  //global crossing keys variable
      var cfCrossings; //global crossfilter crossings variable
      var cfCatchments; //global crossfilter crossings variable
      var crossingFilters = {}    //global cross filter dimension variable
      var catchmentFilters = {}    //global cross filter dimension variable
      var covType = {};   //global covariate data type variable
      var binWidth = {};   //global histogram width variable
      var brush = {};   //global brush variable
      var hists = {};   //global histogram object variable
      var graphs = [];   //global list of current graphs variable

      //******Wait for all topoJSON files to load
      queue()
        .defer(d3.json, 'streams_topo.json')
        .defer(d3.json, 'crossings_topo.json')
        .defer(d3.json, 'catchments_topo.json')
        .defer(d3.tsv, 'crossing_covariates.tsv')
        .defer(d3.tsv, 'catchment_covariates.tsv')
        .await(displayIt);






      //******Bind topoJSON data
      function displayIt(error, streamData, crossingData, catchData, crossCov, catchCov) {
        streams = topojson.feature(streamData, streamData.objects.edges_nodes_fbar_tbar_wgs84);
        crossings = topojson.feature(crossingData, crossingData.objects.Deerfield_barriers_merged_09_08_15_10M_snap_nodups_featureid_wgs84);
        catchments = topojson.feature(catchData, catchData.objects.Deerfield_NHD_Hi_Res_Catchments_wgs84);

        crossCov = readTSV(crossCov, crossings, "unique_id", "crossings");
        catchCov = readTSV(catchCov, catchments, "featureid", "catchments");

        bounds = d3.geo.bounds(catchments);
        path = d3.geo.path()
                 .projection(projectPoint)
                 .pointRadius(3.5);
        
        //******Get keys for crossings and catchment properties
        crossKeys = d3.keys(crossCov[0]);
        catchKeys = d3.keys(catchCov[0]);

        //******Make crossfilter dimensions
        cfDimension("crossings", crossingFilters, crossCov, cfCrossings);
        cfDimension("catchments", catchmentFilters, catchCov, cfCatchments);

        //******Add drop down box to select crossing attribute for styling
        addLegend("crossings", crossKeys, crossG, crossings);
        addLegend("catchments", catchKeys, catchG, catchments);

        //******Add drop down box to select attributes for filtering
        addFilterSelect("crossings", crossKeys, crossingFilters);
        addFilterSelect("catchments", catchKeys, catchmentFilters);
        
        //******Add crossings layer
        map.addLayer(streamTogSVG);
        map.addLayer(crossTogSVG);
        d3.select("#catchmentsSelect").property("selectedIndex", function() {return 1;});
        map.addLayer(catchTogSVG);
       
        //******Set map view
        map.on("viewreset", reset);
        reset();
      }
      

     



     function addFilterSelect(layer, keys, filter) {
        //******Add drop down box to select crossing attribute for filtering
        d3.select("#filterTitle")
          .append("h5")
          .attr("id", layer + "FilterTitle")
          .text(layer.charAt(0).toUpperCase() + layer.slice(1));

        var select = d3.select("#filterSelect")
          .append("select")
          .attr("class", "legAttrList")
          .attr("id", layer + "FilterSelect")
          .on("change", function () { addFilter(this.value, layer); });

        plusKeys = keys;
        plusKeys.splice(0,0, "none");
        select.selectAll("option")
          .data(plusKeys)
          .enter().append("option")
          .attr("value", function (d, i) { return plusKeys[i]; })
          .text(function (d, i) { return plusKeys[i]; });

        d3.select("#totals")
          .append("div")
          .html('<span id="active">' + filter.all.value() + '</span> of <span id="total">' + filter.all.value() + '</span> ' + layer + ' selected'); ;
      }




      function addLegend(layer, keys, g, topo) {
        var select = d3.select("#" + layer + "Legend")
          .append("div")
          .attr("class", "legAttrSel")
          .append("select")
          .attr("class", "legAttrList")
          .attr("id", layer + "Select")
          .on("change", function () { changeStyle(this.value, g, layer, topo); });

        select.selectAll("option")
          .data(keys)
          .enter().append("option")
          .attr("value", function (d, i) { return keys[i]; })
          .text(function (d, i) { return keys[i]; });
      }





      //*****Reposition the SVG to cover the features.
      function reset() {
        //******Set bounds (using Deerfield HUC 8 bounds)
        var bottomLeft = projectPoint(bounds[0]);
        var topRight = projectPoint(bounds[1]);
          
        topoSVG.attr('width', topRight[0] - bottomLeft[0])
          .attr('height', bottomLeft[1] - topRight[1])
          .style('margin-left', bottomLeft[0] + 'px')
          .style('margin-top', topRight[1] + 'px');

        var translation = -bottomLeft[0] + ',' + -topRight[1];

        //******Select all layer g elements
        var tmpG = topoSVG.selectAll("g");

        //******Loop through each g element and transform the path
        tmpG[0].forEach(function(g) {
          var curG = d3.select(g);
          var feature = curG.selectAll("path");
          curG.attr('transform', 'translate(' + -bottomLeft[0] + ',' + -topRight[1] + ')');
          feature.attr("d", path);
        });  
      }






      //******Use Leaflet to implement a D3 geometric transformation.
      function projectPoint(x) {
        var point = map.latLngToLayerPoint(new L.LatLng(x[1], x[0]));
        return [point.x, point.y];
      }






      //******Transform TSV strings to values if appropriate and add to topojson
      function readTSV(tmpData, tmpTopo, ID_key, layer) {
        //******Get keys and values from TSV data and fill out covariate data type
        var tmpKeys = d3.keys(tmpData[0]);
        var tmpVals = d3.values(tmpData[0]);
        covType[layer] = {};
        tmpVals.forEach(function(val,i){
          if (isNaN(val) == false) {
            covType[layer][tmpKeys[i]] = "number";
          }
          else {
            covType[layer][tmpKeys[i]] = "string";
          }
        });

        //******Change TSV attribute strings to values if appropriate
        var tmpCov = tmpData.map(function(d) {
          var tmpJSON = {};
          tmpVals.forEach(function(val,i){ 
            if (isNaN(val) == false) {
              tmpJSON[tmpKeys[i]] = +d[tmpKeys[i]];
            }
            else {
              tmpJSON[tmpKeys[i]] = d[tmpKeys[i]];
            }
          });
          return tmpJSON;
        });    

        //*******Map TSV to ID_key attribute (in this case either unique_id (crossings) or featureid (catchments)
        var tmpMap = d3.map(tmpCov, function(d) {return d[ID_key];});

        //*******Add TSV data to topojson
        tmpTopo.features.forEach(function(d) { 
          try {
            tmpKeys.forEach(function(key) {
              d.properties[key] = tmpMap.get(d.id)[key];
            });
          }
          catch(err) { 
            console.log("No TSV data for id " + d.id);
          }
        });

        return tmpCov;
      }





      //*******Make crossfilter dimensions and grouped dimensions
      function cfDimension(layer, filter, covariates, cross_filter) {
        //******Assign crossing covariates to a crossfilter variable

        cross_filter = crossfilter(covariates);
        filter.all = cross_filter.groupAll();
        binWidth[layer] = {};

        //******Dimension and group each covariate
        crossKeys.forEach(function(key, i) {
          filter[key] = cross_filter.dimension(function(d) { return d[key]; } );
          if (covType["crossings"][key] == "number") {
            var tmpTop = filter[key].top(1);
            var tmpBot = filter[key].bottom(1);
            var divVal = (tmpTop[0][key] - tmpBot[0][key]) / 40;
            binWidth[layer][key] = divVal;
            filter[key + "s"] = filter[key].group(function(d) {return Math.floor(d / divVal) * divVal;});
          }
          else {
            filter[key + "s"] = filter[key].group();
          }
        });
       }








      //*******Show crossings attribute in tooltip
      function showIt(tmpID) {
        tooltip.text(tmpID);
        tooltip.style("visibility", "visible");
      }






      //*******Change feature styles
      function changeStyle(tmpAtt, tmpG, tmpClass, tmpTopo) {
        //*******Select features
        var curG = d3.select(tmpG[0][0]);
        var tmpFeat = curG.selectAll("." + tmpClass);

        //*******Get data for passed in attribute
        console.log(tmpTopo.features[0]);
        var tmpVals = d3.values(tmpTopo.features).map(function(d) { return d.properties[tmpAtt]; });

        var tmpSet = d3.set(tmpVals);
        var tmpMin = d3.min([5, tmpSet.size()])

        //*******Make a color scale
        if (tmpMin > 2) {
          var newColor = d3.scale.quantize()
            .domain([d3.max([0,d3.min(tmpVals)]), d3.max(tmpVals)]);

          switch(tmpClass) {
            case "crossings":
              newColor.range(colorbrewer.RdYlBu[tmpMin]);
              break;
            case "catchments":
              newColor.range(colorbrewer.YlGn[tmpMin]);
              break;
            case "streams":
              newColor.range(colorbrewer.YlGnBu[9]);
              break;
          }
        }
        else {
          var newColor = d3.scale.quantize()
            .domain([1, 2])
            .range(["#d7191c", "#2c7bb6"]);
        }

        //*******Style and label crossings by attribute value
        tmpFeat.style("fill", function(d) {return newColor(d.properties[tmpAtt]); });
        tmpFeat.attr("id", function(d) { return (tmpAtt + ": " + d.properties[tmpAtt]); })

        //*******Make a legend
        var list = d3.select("." + tmpClass + "-list-inline");
        list.remove();

        var legend = d3.select("#" + tmpClass + "Legend")
         .append("ul")
         .attr("class", tmpClass + "-list-inline");

        var keys = legend.selectAll("li.key")
          .data(newColor.range());

        keys.enter().append("li")
          .attr("class", "key")
          .style("border-top-color", String)
          .text(function(d) {
            var r = newColor.invertExtent(d);
            return r[0].toFixed(1);
          });
       }






      //*******Add crossfilter histogram
      function addFilter(tmpKey, layer) {
        if (graphs.indexOf(tmpKey) > -1) {
          return;
        }
        else if (tmpKey == "none") {
          var tmpGraphs = graphs.slice();
          tmpGraphs.forEach(function(d) {removeFilter(d);});
          return;
        }
        else {
          graphs.push(tmpKey);
        }

        //******Define graph attributes
        var margin = {top: 10, right: 10, bottom: 20, left: 10},
          width = 390 - margin.left - margin.right,
          height = 100 - margin.top - margin.bottom;

        var x = d3.scale.linear()
          .rangeRound([0, width]);

        var y = d3.scale.linear()
          .range([height, 0]);

        var xAxis = d3.svg.axis()
          .scale(x)
          .orient("bottom")
          .ticks(10);


        //******Add brush
        brush[tmpKey] = d3.svg.brush()
          .x(x)
          .on("brushstart", function() { brushStart(tmpKey); })
          .on("brush", function() { brushMove(tmpKey); })
          .on("brushend", function() { brushEnd(tmpKey); });


        //******Add chart div, title div, and reset option
        d3.select("#charts")
          .append("div")
            .attr("class", "chart")
            .attr("id", tmpKey)
          .append("div")
            .attr("class", "title")
            .attr("id", "title-" + tmpKey)
            .style("margin-left", "2px")
            .text(tmpKey)
          .append("a")
            .attr("class", "reset")
            .text("reset")
            .on("click", function() { brushReset(tmpKey); });


        //******Add remove button
        d3.select("#title-" + tmpKey)
          .append("div")
            .attr("class", "btn btn-default btn-xs pull-right")
            .attr("title", tmpKey)
            .text("x")
            .on("click", function() { removeFilter(this.title); });


        //******Add stats div and extent
        d3.select("#" + tmpKey)
          .append("div")
            .attr("class", "stats")
            .attr("id", "stats-" + tmpKey)
          .append("span")
            .attr("class", "extent")
            .attr("id", "extent-" + tmpKey);


        //******Add mean to stats div
        d3.select("#stats-" + tmpKey)
          .append("span")
            .attr("class", "mean pull-right")
            .attr("id", "mean-" + tmpKey);


        //******Add svg
        var svg = d3.select("#" + tmpKey)
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .attr("id", "svg-" + tmpKey)
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
            .attr("id", "g-" + tmpKey);


        //******Get data and make graph
        var tmpData = crossingFilters[tmpKey + "s"].all();

        x.domain([tmpData[0].key, tmpData[tmpData.length - 1].key + binWidth["crossings"][tmpKey]]);
        y.domain([0, d3.max(tmpData, function(d) { return d.value; })]);

        svg.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height + ")")
          .call(xAxis);

        var tmpData = crossingFilters[tmpKey + "s"].all();
        hists[tmpKey] = {"x": x, "y": y, "height": height, "width": width};
      
        svg.selectAll(".bar")
            .data(tmpData)
          .enter().append("rect")
            .attr("class", "foreground bar")
            .attr("x", function(d) { return x(d.key); })
            .attr("width", (x.range()[1] - x.range()[0])/40)  
            .attr("y", function(d) { return y(d.value); })
            .attr("height", function(d) { return height - y(d.value); });
      
        var gBrush = svg.append("g")
          .attr("class", "brush")
          .attr("id", "brush-" + tmpKey)
          .call(brush[tmpKey]);

        gBrush.selectAll("rect").attr("height", height);
        gBrush.selectAll(".resize").append("path").attr("d", resizePath);

        brushReset(tmpKey);

        function resizePath(d) {
          var e = +(d == "e"),
            x = e ? 1 : -1,
            y = height / 3;
          return "M" + (0.5 * x) + "," + y + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6) + "V" + (2 * y - 6) + "A6,6 0 0 " + e + " " + (0.5 * x) + "," + (2 * y) + "Z" + "M" + (2.5 * x) + "," + (y + 8) + "V" + (2 * y - 8) + "M" + (4.5 * x) + "," + (y + 8) + "V" + (2 * y - 8);
        }
      }








      //******Remove graph from window
      function removeFilter(tmpKey) {
        graphs.splice(graphs.indexOf(tmpKey), 1);
        brushReset(tmpKey);
        var select = d3.select("#" + tmpKey);
        select.remove();
      }



      function brushStart(tmpKey) {
       //console.log(tmpKey);
      }


      function brushMove(tmpKey) {
        crossingFilters[tmpKey].filterRange([brush[tmpKey].extent()[0], brush[tmpKey].extent()[1]]);
        filterMap(tmpKey);
      }

      function brushEnd(tmpKey) {
        crossingFilters[tmpKey].filterRange([brush[tmpKey].extent()[0], brush[tmpKey].extent()[1]]);       
        filterMap(tmpKey);
      }

      function brushReset(tmpKey) {
        d3.select("#brush-" + tmpKey).call(brush[tmpKey].clear());
        crossingFilters[tmpKey].filterAll();
        filterMap(tmpKey);
      }

      function filterMap(tmpKey) {
        var tmpSubset = crossingFilters["unique_id"].top(Infinity);
        var tmpID = tmpSubset.map(function(d) {return d.unique_id;});
        var tmpData = d3.selectAll(".crossings").data();
        var tmpSel = d3.selectAll(".crossings");
        tmpSel.style("opacity", function(d, i) { 
          if (tmpID.indexOf(tmpData[i].properties.unique_id) > -1) {
            return 1;
          }
          else {
            return 0;
          }
        });

        //******Update crossings selected
        d3.select("#active").html(crossingFilters.all.value());

        //******Update filter range
        if (brush[tmpKey].empty()) {
          d3.select("#extent-" + tmpKey).html(crossingFilters[tmpKey].bottom(1)[0][tmpKey].toFixed(1) + " - " + crossingFilters[tmpKey].top(1)[0][tmpKey].toFixed(1));
        }
        else {
          d3.select("#extent-" + tmpKey).html(brush[tmpKey].extent()[0].toFixed(1) + " - " + brush[tmpKey].extent()[1].toFixed(1));
        }

        updateStats(tmpKey);

        updateHistogram(tmpKey);
      }

      function updateStats(tmpKey) {
        //******Update filter mean
        graphs.forEach(function(key) {
          if (crossingFilters["all"].value() > 0 ) {
            d3.select("#mean-" + key).html("Mean: " + d3.mean(crossingFilters[key].top(Infinity), function(d) { return d[key]; }).toFixed(1));       
          }
          else {
            d3.select("#mean-" + key).html("Mean: 0.0");
          }
        });
      }

      function updateHistogram(tmpKey) {
        graphs.forEach(function(d) {
          if (d != tmpKey) {

            var tmpData = crossingFilters[d + "s"].all();
            var svg = d3.select("#g-" + d);
            var x = hists[d].x;
            var y = hists[d].y;
            var height = hists[d].height;
            var width = hists[d].width;
            y.domain([0, d3.max(tmpData, function(d) { return d.value; })]);

            var update = svg.selectAll(".bar")
              .data(tmpData);

            update.exit().remove();
            update.enter().insert("rect", ":first-child")
              .attr("class", "foreground bar");
            update
                .attr("x", function(d) { return x(d.key); })
                .attr("width", (x.range()[1] - x.range()[0])/40)  
                .attr("y", function(d) { return y(d.value); })
                .attr("height", function(d) { return height - y(d.value); });
          }
        });
      }


    </script>
  </body>
</html>