<!DOCTYPE html>
<html>
  <head>
    <title>Deerfield Watershed Road-Stream Crossing Explorer</title>
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" />
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
    <link rel="stylesheet" href="http://colorbrewer2.org/export/colorbrewer.css" />
    <link rel="stylesheet" href="styles/Control.BingGeocoder.css" />
    <link rel="stylesheet" href="styles/Control.maxExtent.css" />
    <link rel="stylesheet" href="styles/app.css" />
    <link rel="stylesheet" href="styles/deerfield_crossings.css" />

    <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>
    <script src="http://maps.google.com/maps/api/js?v=3.2&sensor=false"></script>
    <script src="Bing_tile.js"></script>
    <script src="Google_tile.js"></script>
    <script src="Control.BingGeocoder.js"></script>
    <script src="Control.maxExtent.js"></script>

    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="http://colorbrewer2.org/export/colorbrewer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min.js"></script>
    <script src="crossfilter.min.js"></script>

  </head>

  <body>
    <div id="map"></div>

    <script type='text/javascript'>
      //******Add Map
      var map = new L.Map('map', {center: new L.LatLng(42.74, -72.83), zoomControl: false, zoom: 10, minZoom: 2, maxZoom: 20, inertiaDeceleration: 1000});

      //******Add map controls
      L.control.scale({ maxWidth: 200 }).addTo(map);
      L.control.zoom({ position: 'topleft', zoomInText: '+', zoomOutText: '-' }).addTo(map);
      var maxExtent = new L.Control.maxExtent();
      map.addControl(maxExtent);

      //******Bing geocoder control
      var tmpPoint = new L.marker;
      var bingGeocoder = new L.Control.BingGeocoder('At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn', { callback: function (results) {
                     var bbox = results.resourceSets[0].resources[0].bbox,
                            first = new L.LatLng(bbox[0], bbox[1]),
                            second = new L.LatLng(bbox[2], bbox[3]),
                            tmpBounds = new L.LatLngBounds([first, second]);
                     this._map.fitBounds(tmpBounds);
                     this._map.removeLayer(tmpPoint);
                     tmpPoint = new L.marker(results.resourceSets[0].resources[0].point.coordinates).bindPopup(results.resourceSets[0].resources[0].address.formattedAddress);
                     this._map.addLayer(tmpPoint);
                   }
      });

      map.addControl(bingGeocoder);

      //******Add basemaps
      var googleHybrid = new L.Google('HYBRID');
      var googleSatellite = new L.Google('SATELLITE');
      var googleStreet = new L.Google('ROADMAP');
      var googleTerrain = new L.Google('TERRAIN');
      var bingHybrid = new L.BingLayer("At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn", {type: 'AerialWithLabels'});
      var bingSatellite = new L.BingLayer("At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn", {type: 'Aerial'});
      var bingStreet = new L.BingLayer("At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn", {type: 'Road'});

      map.addLayer(googleHybrid);

      //******Add Geoserver Layers
      var gsHuc8 = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/crossings/wms", {
        layers: 'crossings:deerfield_huc8',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsTowns = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/crossings/wms", {
        layers: 'crossings:deerfield_towns',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsCounties = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/crossings/wms", {
        layers: 'crossings:deerfield_counties',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsDOTDistricts = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/crossings/wms", {
        layers: 'crossings:deerfield_dot_districts',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });


      //******Make d3 vector layers variable
      var topoSVG = d3.select(map.getPanes().overlayPane).append("svg");
      var catchG = topoSVG.append("g").attr("class", "leaflet-zoom-hide").attr("id", "catchG");
      var streamG = topoSVG.append("g").attr("class", "leaflet-zoom-hide").attr("id", "streamG");
      var crossG = topoSVG.append("g").attr("class", "leaflet-zoom-hide").attr("id", "crossG");

      //******Make dummy layer variables for layer controller
      var crossTogSVG = d3.select(map.getPanes().overlayPane).append("svg");

      crossTogSVG.onAdd = function(map) {
        //******Add Deerfield road/stream crossings
        var tmpFeats = crossG.selectAll(".crossings")
            .data(crossings.features)
          .enter().append("path")
            .attr("d", path)
            .attr("class", "crossings")
            .on("mouseover", function(data) { showIt(this.id); })
            .on("mousemove", function() { return tooltip.style("top", (d3.event.pageY-10) + "px").style("left", (d3.event.pageX+10) + "px"); })
            .on("mouseout", function() { return tooltip.style("visibility", "hidden"); });
        changeStyle(d3.select("#crossingsSelect").node().value, crossings);
        d3.select("#crossingsLegend").style("display", "block");
      }

      crossTogSVG.onRemove = function(map) {
        var tmpFeats = crossG.selectAll(".crossings");
        tmpFeats.remove();
        d3.select("#crossingsLegend").style("display", "none");
      }

      var streamTogSVG = d3.select(map.getPanes().overlayPane).append("svg");
      //var streamTogG = streamTogSVG.append("g").attr("class", "leaflet-zoom-hide");
  
      streamTogSVG.onAdd = function(map) {
        //******Add Deerfield streams
        var tmpFeats = streamG.selectAll(".streams")
            .data(streams.features)
          .enter().insert("path", ":first-child")
            .attr("d", path)
            .attr("class", "streams")
            .attr("id", function(data) { return ("str_order: " + data.properties.str_order); })
            .style("stroke-width", function(data) { return (0.5 + (0.5 * data.properties.str_order) + "px") ; })
            .style("stroke", function(data) { return streamColor(10 - data.properties.str_order); })
            .on("mouseover", function(data) { showIt(this.id); })
            .on("mousemove", function() { return tooltip.style("top", (d3.event.pageY-10) + "px").style("left", (d3.event.pageX+10) + "px"); })
            .on("mouseout", function() { return tooltip.style("visibility", "hidden"); });
       }

      streamTogSVG.onRemove = function(map) {
        var tmpFeats = streamG.selectAll(".streams");
        tmpFeats.remove();
      }

      var catchTogSVG = d3.select(map.getPanes().overlayPane).append("svg");
      //var catchTogG = catchTogSVG.append("g").attr("class", "leaflet-zoom-hide");

      catchTogSVG.onAdd = function(map) {
        //******Add Deerfield catchments
        var tmpFeats = catchG.selectAll(".catchments")
            .data(catchments.features)
          .enter().insert("path", ":first-child")
            .attr("d", path)
            .attr("class", "catchments")
            .on("mouseover", function(data) { showIt(this.id); })
            .on("mousemove", function() { return tooltip.style("top", (d3.event.pageY-10) + "px").style("left", (d3.event.pageX+10) + "px"); })
            .on("mouseout", function() { return tooltip.style("visibility", "hidden"); });
        changeStyle(d3.select("#catchmentsSelect").node().value, catchments);
        d3.select("#catchmentsLegend").style("display", "block");
      }

      catchTogSVG.onRemove = function(map) {
        var tmpFeats = catchG.selectAll(".catchments");
        tmpFeats.remove();
        d3.select("#catchmentsLegend").style("display", "none");
      } 

      map.addLayer(gsHuc8);

      //******Make layer controller
      var baseLayers = {"Google Hybrid": googleHybrid, "Google Satellite": googleSatellite, "Google Street": googleStreet, "Google Terrain": googleTerrain, "Bing Hybrid": bingHybrid, "Bing Satellite": bingSatellite, "Bing Street": bingStreet};
      var overlays = {"DOT Districts": gsDOTDistricts, "Counties": gsCounties, "Towns": gsTowns, "Deerfield Watershed": gsHuc8, "Catchments": catchTogSVG, "Streams": streamTogSVG, "Crossings": crossTogSVG};
      L.control.layers(baseLayers, overlays).addTo(map);

/*
      //******Make header div
      d3.select("body")
        .append("div")
        .attr("class", "header");
*/

      //******Make tooltip for displaying attribute data
      var tooltip = d3.select("body")
        .append("div")
        .attr("class", "d3Tooltip");

      //******Make div for legend
      d3.select("body")
        .append("div")
        .attr("class", "legend")
        .attr("id", "legendDiv");

      d3.select("#legendDiv")
        .append("div")
        .attr("id", "crossingsLegend");

      d3.select("#crossingsLegend")
        .append("h4")
        .text("Crossing Attributes")
        .attr("class", "legTitle");

      d3.select("#legendDiv")
        .append("div")
        .attr("id", "catchmentsLegend")
        .style("display", "none");

      d3.select("#catchmentsLegend")
        .append("h4")
        .text("Catchment Attributes")
        .attr("class", "legTitle")
        .style("margin-top", "20px");

 

      //******Make divs for filter titles and selects
      d3.select("body")
        .append("div")
        .attr("class", "legend")
        .attr("id", "filters");

      d3.select("#filters")
        .append("h4")
        .text("Filters")
        .attr("class", "legTitle");

      d3.select("#filters")
        .append("div")
        .attr("id", "filterTitle");

      d3.select("#filters")
        .append("div")
        .attr("class", "legAttrSel")
        .attr("id", "filterSelect");

      //*******Add checkbox for linking crossfilters
      d3.select("#filters")
        .append("input")
        .attr({type: "checkbox", name: "cfLink", value: "linked"})
        .attr("id", "cfLink")
        .attr("checked", true)
        .style("margin", "9px");

      d3.select("#filters")
        .append("label")
        .text("Link Filters")
        .attr("id", "linkLabel");

      //*******Add div for histograms
      d3.select("#filters")
        .append("hr")
        .attr("class", "hr");

      d3.select("#filters")
        .append("div")
          .attr("id", "charts")
        .append("div")
          .attr("id", "totals");





      //******Make color scale for streams
      var streamColor = d3.scale.quantize()
        .domain([1, 9])
        .range(colorbrewer.YlGnBu[9]);






      //******Make variables for d3 topoJSON and TSV data
      var crossings;  //global crossings topojson variable
      var catchments;  //global catchments topojson variable
      var streams;  //global stream topojson variable
      var bounds;  //global bounds variable
      var path;    //global path variable
      var crossCov;   //global crossing covariate data variable
      var catchCov;   //global catchment covariate data variable
      var streamCov;   //global stream covariate data variable
      var brush = {};   //global brush variable
      var hist = {};   //global histogram object variable
      var graphs = [];   //global list of current graphs variable

      //******Wait for all topoJSON files to load
      queue()
        .defer(d3.json, 'streams_topo.json')
        .defer(d3.json, 'crossings_topo.json')
        .defer(d3.json, 'catchments_topo.json')
        .defer(d3.tsv, 'crossings_covariates.tsv')
        .defer(d3.tsv, 'catchments_covariates.tsv')
        .defer(d3.tsv, 'streams_covariates.tsv')
        .await(displayIt);






      //******Bind topoJSON data
      function displayIt(error, streamData, crossingData, catchData, crossCov, catchCov, streamCov) {
        crossings = topojson.feature(crossingData, crossingData.objects.Deerfield_barriers_merged_09_08_15_10M_snap_nodups_featureid_wgs84);
        catchments = topojson.feature(catchData, catchData.objects.Deerfield_NHD_Hi_Res_Catchments_wgs84);
        streams = topojson.feature(streamData, streamData.objects.edges_nodes_fbar_tbar_wgs84);

        //******Add properties to topoJSONs
        crossings.class = "crossings";
        crossings.g = crossG;
        crossings.uniqueID = "unique_id";
        crossings.covType = {};
        crossings.filter = {};
        crossings.binWidth = {};
        brush.crossings = {};
        hist.crossings = {};

        catchments.class = "catchments";
        catchments.g = catchG;
        catchments.uniqueID = "featureid";
        catchments.covType = {};
        catchments.filter = {};
        catchments.binWidth = {};
        brush.catchments = {};
        hist.catchments = {};

        streams.class = "streams";
        streams.g = catchG;
        streams.uniqueID = "unique_id";
        streams.covType = {};
        streams.filter = {};
        streams.binWidth = {};
        brush.streams = {};
        hist.streams = {};

        //******Add covatiate TSV files to topojson
        crossCov = readTSV(crossCov, crossings);
        catchCov = readTSV(catchCov, catchments);
        streamCov = readTSV(streamCov, streams);
        
        //******Get keys for crossings and catchment properties
        crossings.keys = d3.keys(crossCov[0]);
        catchments.keys = d3.keys(catchCov[0]);
        streams.keys = d3.keys(streamCov[0]);

        //******Make crossfilter dimensions
        cfDimension(crossings, crossCov);
        cfDimension(catchments, catchCov);
        cfDimension(streams, streamCov);

        //******Release covariate data
        crossCov = null;
        catchCov = null;
        streamCov = null;

        //******Set d3 map data
        bounds = d3.geo.bounds(catchments);
        path = d3.geo.path()
                 .projection(projectPoint)
                 .pointRadius(3.5);

        //******Add drop down box to select crossing attribute for styling
        addLegend(crossings);
        addLegend(catchments);

        //******Add drop down box to select attributes for filtering
        addFilterSelect(crossings);
        addFilterSelect(catchments);
        
        //******Add topoJSON layers
        map.addLayer(crossTogSVG);
        d3.select("#catchmentsSelect").property("selectedIndex", function() {return 1;});
        map.addLayer(catchTogSVG);
        map.addLayer(streamTogSVG);
       
        //******Set map view
        map.on("viewreset", reset);
        reset();
      }
      

     



     function addFilterSelect(topo) {
        //******Add drop down box to select crossing attribute for filtering
        d3.select("#filterTitle")
          .append("h5")
          .attr("id", topo.class + "FilterTitle")
          .text(topo.class.charAt(0).toUpperCase() + topo.class.slice(1));

        var select = d3.select("#filterSelect")
          .append("select")
          .attr("class", "legAttrList")
          .attr("id", topo.class + "FilterSelect")
          .on("change", function () { addFilter(this.value, topo); });

        var plusKeys = topo.keys;
        plusKeys.splice(0,0, "none");
        select.selectAll("option")
          .data(plusKeys)
          .enter().append("option")
          .attr("value", function (d, i) { return plusKeys[i]; })
          .text(function (d, i) { return plusKeys[i]; });

        d3.select("#totals")
          .append("div")
          .html('<span id="active-' + topo.class + '">' + topo.filter.all.value() + '</span> of <span id="total">' + topo.filter.all.value() + '</span> ' + topo.class + ' selected'); ;
      }




      function addLegend(topo) {
        var select = d3.select("#" + topo.class + "Legend")
          .append("div")
          .attr("class", "legAttrSel")
          .append("select")
          .attr("class", "legAttrList")
          .attr("id", topo.class + "Select")
          .on("change", function () { changeStyle(this.value, topo); });

        select.selectAll("option")
          .data(topo.keys)
          .enter().append("option")
          .attr("value", function (d, i) { return topo.keys[i]; })
          .text(function (d, i) { return topo.keys[i]; });
      }





      //*****Reposition the SVG to cover the features.
      function reset() {
        //******Set bounds (using Deerfield HUC 8 bounds)
        var bottomLeft = projectPoint(bounds[0]);
        var topRight = projectPoint(bounds[1]);
          
        topoSVG.attr('width', topRight[0] - bottomLeft[0])
          .attr('height', bottomLeft[1] - topRight[1])
          .style('margin-left', bottomLeft[0] + 'px')
          .style('margin-top', topRight[1] + 'px');

        var translation = -bottomLeft[0] + ',' + -topRight[1];

        //******Select all layer g elements
        var tmpG = topoSVG.selectAll("g");

        //******Loop through each g element and transform the path
        tmpG[0].forEach(function(g) {
          var curG = d3.select(g);
          var feature = curG.selectAll("path");
          curG.attr('transform', 'translate(' + -bottomLeft[0] + ',' + -topRight[1] + ')');
          feature.attr("d", path);
        });  
      }






      //******Use Leaflet to implement a D3 geometric transformation.
      function projectPoint(x) {
        var point = map.latLngToLayerPoint(new L.LatLng(x[1], x[0]));
        return [point.x, point.y];
      }






      //******Transform TSV strings to values if appropriate and add to topojson
      function readTSV(tmpData, topo) {
        //******Get keys and values from TSV data and fill out covariate data type
        var tmpKeys = d3.keys(tmpData[0]);
        var tmpVals = d3.values(tmpData[0]);

        tmpVals.forEach(function(val,i){
          if (isNaN(val) == false) {
            topo.covType[tmpKeys[i]] = "number";
          }
          else {
            topo.covType[tmpKeys[i]] = "string";
          }
        });

        //******Change TSV attribute strings to values if appropriate
        var tmpCov = tmpData.map(function(d) {
          var tmpJSON = {};
          tmpVals.forEach(function(val,i){ 
            if (isNaN(val) == false) {
              tmpJSON[tmpKeys[i]] = +d[tmpKeys[i]];
            }
            else {
              tmpJSON[tmpKeys[i]] = d[tmpKeys[i]];
            }
          });
          return tmpJSON;
        });    

        //*******Map TSV to ID_key attribute (in this case either unique_id (crossings) or featureid (catchments)
        var tmpMap = d3.map(tmpCov, function(d) {return d[topo.uniqueID];});

        //*******Add TSV data to topojson
        topo.features.forEach(function(d) { 
          try {
            tmpKeys.forEach(function(key) {
              d.properties[key] = tmpMap.get(d.id)[key];
            });
          }
          catch(err) { 
            console.log("No TSV data for id " + d.id);
          }
        });

        return tmpCov;
      }





      //*******Make crossfilter dimensions and grouped dimensions
      function cfDimension(topo, covariates) {
        //******Assign crossing covariates to a crossfilter variable

        var tmpCF = crossfilter(covariates);
        topo.filter.all = tmpCF.groupAll();
        topo.binWidth = {};

        //******Dimension and group each covariate
        topo.keys.forEach(function(key, i) {
          topo.filter[key] = tmpCF.dimension(function(d) { return d[key]; } );
          if (topo.covType[key] == "number") {
            var tmpTop = topo.filter[key].top(1);
            var tmpBot = topo.filter[key].bottom(1);
            var divVal = (tmpTop[0][key] - tmpBot[0][key]) / 40;
            topo.binWidth[key] = divVal;
            topo.filter[key + "s"] = topo.filter[key].group(function(d) {return Math.floor(d / divVal) * divVal;});
          }
          else {
            topo.filter[key + "s"] = topo.filter[key].group();
          }
        });
       }








      //*******Show crossings attribute in tooltip
      function showIt(tmpID) {
        tooltip.text(tmpID);
        tooltip.style("visibility", "visible");
      }






      //*******Change feature styles
      function changeStyle(tmpAtt, topo) {
        //*******Select features
        var curG = d3.select(topo.g[0][0]);
        var tmpFeat = curG.selectAll("." + topo.class);

        //*******Get data for passed in attribute
        var tmpVals = d3.values(topo.features).map(function(d) { return d.properties[tmpAtt]; });

        var tmpSet = d3.set(tmpVals);
        var tmpMin = d3.min([5, tmpSet.size()])

        //*******Make a color scale
        if (tmpMin > 2) {
          var newColor = d3.scale.quantize()
            .domain([d3.max([0,d3.min(tmpVals)]), d3.max(tmpVals)]);

          switch(topo.class) {
            case "crossings":
              newColor.range(colorbrewer.RdYlBu[tmpMin]);
              break;
            case "catchments":
              newColor.range(colorbrewer.YlGn[tmpMin]);
              break;
            case "streams":
              newColor.range(colorbrewer.YlGnBu[9]);
              break;
          }
        }
        else {
          var newColor = d3.scale.quantize()
            .domain([1, 2])
            .range(["#d7191c", "#2c7bb6"]);
        }

        //*******Style and label crossings by attribute value
        tmpFeat.style("fill", function(d) {return newColor(d.properties[tmpAtt]); });
        tmpFeat.attr("id", function(d) { return (tmpAtt + ": " + d.properties[tmpAtt]); })

        //*******Make a legend
        var list = d3.select("." + topo.class + "-list-inline");
        list.remove();

        var legend = d3.select("#" + topo.class + "Legend")
         .append("ul")
         .attr("class", topo.class + "-list-inline");

        var keys = legend.selectAll("li.key")
          .data(newColor.range());

        keys.enter().append("li")
          .attr("class", "key")
          .style("border-top-color", String)
          .text(function(d) {
            var r = newColor.invertExtent(d);
            return r[0].toFixed(1);
          });
       }






      //*******Add crossfilter histogram
      function addFilter(tmpKey, topo) {
        if (graphs.indexOf(topo.class + "-" + tmpKey) > -1) {
          return;
        }
        else if (tmpKey == "none") {
          var tmpGraphs = graphs.slice();
          tmpGraphs.forEach(function(d) {
            if (d.indexOf(topo.class) > -1) {
              removeFilter(d, topo);
            }
          });
          return;
        }
        else {
          graphs.push(topo.class + "-" + tmpKey);
        }

        //******Define graph attributes
        var margin = {top: 10, right: 10, bottom: 20, left: 10},
          width = 390 - margin.left - margin.right,
          height = 100 - margin.top - margin.bottom;

        var x = d3.scale.linear()
          .rangeRound([0, width]);

        var y = d3.scale.linear()
          .range([height, 0]);

        var xAxis = d3.svg.axis()
          .scale(x)
          .orient("bottom")
          .ticks(10);


        //******Add brush
        brush[topo.class][tmpKey] = d3.svg.brush()
          .x(x)
          .on("brushstart", function() { brushStart(tmpKey, topo); })
          .on("brush", function() { brushMove(tmpKey, topo); })
          .on("brushend", function() { brushEnd(tmpKey, topo); });


        //******Add chart div, title div, and reset option
        d3.select("#charts")
          .append("div")
            .attr("class", "chart")
            .attr("id", topo.class + "-" + tmpKey)
          .append("div")
            .attr("class", "title")
            .attr("id", "title-" + topo.class + "-" + tmpKey)
            .style("margin-left", "2px")
            .text(tmpKey)
          .append("a")
            .attr("class", "reset")
            .text("reset")
            .on("click", function() { brushReset(tmpKey, topo); });


        //******Add remove button
        d3.select("#title-" + topo.class + "-" + tmpKey)
          .append("div")
            .attr("class", "btn btn-default btn-xs pull-right")
            .attr("title", topo.class + "-" + tmpKey)
            .text("x")
            .on("click", function() { removeFilter(this.title, topo); });


        //******Add stats div and extent
        d3.select("#" + topo.class + "-" + tmpKey)
          .append("div")
            .attr("class", "stats")
            .attr("id", "stats-" + topo.class + "-" + tmpKey)
          .append("span")
            .attr("class", "extent")
            .attr("id", "extent-" + topo.class + "-" + tmpKey);


        //******Add mean to stats div
        d3.select("#stats-" + topo.class + "-" + tmpKey)
          .append("span")
            .attr("class", "mean pull-right")
            .attr("id", "mean-" + topo.class + "-" + tmpKey);


        //******Add svg
        var svg = d3.select("#" + topo.class + "-" + tmpKey)
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .attr("id", "svg-" + topo.class + "-" + tmpKey)
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
            .attr("id", "g-" + topo.class + "-" + tmpKey);


        //******Get data and make graph
        var tmpData = topo.filter[tmpKey + "s"].all();

        x.domain([tmpData[0].key, tmpData[tmpData.length - 1].key + topo.binWidth[tmpKey]]);
        y.domain([0, d3.max(tmpData, function(d) { return d.value; })]);

        svg.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height + ")")
          .call(xAxis);

        var tmpData = topo.filter[tmpKey + "s"].all();
        hist[topo.class][tmpKey] = {"x": x, "y": y, "height": height, "width": width};
      
        svg.selectAll(".bar")
            .data(tmpData)
          .enter().append("rect")
            .attr("class", "foreground bar")
            .attr("x", function(d) { return x(d.key); })
            .attr("width", (x.range()[1] - x.range()[0])/40)  
            .attr("y", function(d) { return y(d.value); })
            .attr("height", function(d) { return height - y(d.value); });
      
        var gBrush = svg.append("g")
          .attr("class", "brush")
          .attr("id", "brush-" + topo.class + "-" + tmpKey)
          .call(brush[topo.class][tmpKey]);

        gBrush.selectAll("rect").attr("height", height);
        gBrush.selectAll(".resize").append("path").attr("d", resizePath);

        brushReset(tmpKey, topo);

        function resizePath(d) {
          var e = +(d == "e"),
            x = e ? 1 : -1,
            y = height / 3;
          return "M" + (0.5 * x) + "," + y + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6) + "V" + (2 * y - 6) + "A6,6 0 0 " + e + " " + (0.5 * x) + "," + (2 * y) + "Z" + "M" + (2.5 * x) + "," + (y + 8) + "V" + (2 * y - 8) + "M" + (4.5 * x) + "," + (y + 8) + "V" + (2 * y - 8);
        }
      }








      //******Remove graph from window
      function removeFilter(class_key, topo) {
        var dash = class_key.indexOf("-");
        var tmpClass = class_key.slice(0, dash);
        var key = class_key.slice(dash + 1, class_key.length);

        graphs.splice(graphs.indexOf(class_key), 1);
        brushReset(key, topo);
        var select = d3.select("#" + class_key);
        select.remove();
      }



      function brushStart(tmpKey, topo) {
        topo.filter[tmpKey].filterRange([brush[topo.class][tmpKey].extent()[0], brush[topo.class][tmpKey].extent()[1]]);
        filterMap(tmpKey, topo);
      }


      function brushMove(tmpKey, topo) {
        topo.filter[tmpKey].filterRange([brush[topo.class][tmpKey].extent()[0], brush[topo.class][tmpKey].extent()[1]]);
        filterMap(tmpKey, topo);
      }

      function brushEnd(tmpKey, topo) {
        topo.filter[tmpKey].filterRange([brush[topo.class][tmpKey].extent()[0], brush[topo.class][tmpKey].extent()[1]]);       
        filterMap(tmpKey, topo);
      }

      function brushReset(tmpKey, topo) {
        d3.select("#brush-" + topo.class + "-" + tmpKey).call(brush[topo.class][tmpKey].clear());
        topo.filter[tmpKey].filterAll();
        filterMap(tmpKey, topo);
      }

      function filterMap(tmpKey, topo) {
        var tmpSubset = topo.filter[topo.uniqueID].top(Infinity);
        var tmpID = tmpSubset.map(function(d) {return d[topo.uniqueID];});
        var tmpData = d3.selectAll("." + topo.class).data();
        var tmpSel = d3.selectAll("." + topo.class);
        tmpSel.style("opacity", function(d, i) { 
          if (tmpID.indexOf(tmpData[i].properties[topo.uniqueID]) > -1) {
            return 1;
          }
          else {
            return 0;
          }
        });

        //******Update crossings selected
        d3.select("#active-" + topo.class).html(topo.filter.all.value());

        //******Update filter range
        if (brush[topo.class][tmpKey].empty() && topo.filter.all.value() > 0) {
          d3.select("#extent-" + topo.class + "-" + tmpKey).html(topo.filter[tmpKey].bottom(1)[0][tmpKey].toFixed(1) + " - " + topo.filter[tmpKey].top(1)[0][tmpKey].toFixed(1));
        }
        else {
          d3.select("#extent-" + topo.class + "-" + tmpKey).html(brush[topo.class][tmpKey].extent()[0].toFixed(1) + " - " + brush[topo.class][tmpKey].extent()[1].toFixed(1));
        }

        updateStats(tmpKey, topo);

        updateHistogram(tmpKey, topo);
      }

      function updateStats(tmpKey, topo) {
        //******Update filter mean
        graphs.forEach(function(class_key) {
          var dash = class_key.indexOf("-");
          var tmpClass = class_key.slice(0, dash);
          var key = class_key.slice(dash + 1, class_key.length);

          if (class_key.indexOf(topo.class) > -1) {
            if (topo.filter["all"].value() > 0 ) {
              d3.select("#mean-" + class_key).html("Mean: " + d3.mean(topo.filter[key].top(Infinity), function(d) { return d[key]; }).toFixed(1));       
            }
            else {
              d3.select("#mean-" + class_key).html("Mean: 0.0");
            }
          }  
        });
      }

      function updateHistogram(tmpKey, topo) {
        graphs.forEach(function(class_key) {
          var dash = class_key.indexOf("-");
          var tmpClass = class_key.slice(0, dash);
          var key = class_key.slice(dash + 1, class_key.length);

          if (class_key.indexOf(topo.class) > -1) { 
            if (class_key != topo.class + "-" + tmpKey) {
              var tmpData = topo.filter[key + "s"].all();
              var svg = d3.select("#g-" + class_key);
              var x = hist[tmpClass][key].x;
              var y = hist[tmpClass][key].y;
              var height = hist[tmpClass][key].height;
              var width = hist[tmpClass][key].width;
              y.domain([0, d3.max(tmpData, function(d) { return d.value; })]);

              var update = svg.selectAll(".bar")
                .data(tmpData);

              update.exit().remove();
              update.enter().insert("rect", ":first-child")
                .attr("class", "foreground bar");
              update
                  .attr("x", function(d) { return x(d.key); })
                  .attr("width", (x.range()[1] - x.range()[0])/40)  
                  .attr("y", function(d) { return y(d.value); })
                  .attr("height", function(d) { return height - y(d.value); });
            }
          }
        });
      }


    </script>
  </body>
</html>