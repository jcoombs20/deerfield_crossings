<!DOCTYPE html>
<html>
  <head>
    <title>Deerfield Watershed Road-Stream Crossing Explorer</title>
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" />
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
    <link rel="stylesheet" href="http://colorbrewer2.org/export/colorbrewer.css" />
    <link rel="stylesheet" href="styles/Control.BingGeocoder.css" />
    <link rel="stylesheet" href="styles/Control.maxExtent.css" />
    <link rel="stylesheet" href="styles/app.css" />
    <link rel="stylesheet" href="styles/deerfield_crossings.css" />

    <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>
    <script src="http://maps.google.com/maps/api/js?v=3.2&sensor=false"></script>
    <script src="Bing_tile.js"></script>
    <script src="Google_tile.js"></script>
    <script src="Control.BingGeocoder.js"></script>
    <script src="Control.maxExtent.js"></script>

    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="http://colorbrewer2.org/export/colorbrewer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min.js"></script>
    <script src="crossfilter.min.js"></script>

  </head>

  <body>
    <div id="map"></div>

    <script type='text/javascript'>
      //******Add Map
      var map = new L.Map('map', {center: new L.LatLng(42.74, -72.83), zoomControl: false, zoom: 10, minZoom: 2, maxZoom: 20, inertiaDeceleration: 1000});

      //******Add map controls
      L.control.scale({ maxWidth: 200 }).addTo(map);
      L.control.zoom({ position: 'topleft', zoomInText: '+', zoomOutText: '-' }).addTo(map);
      var maxExtent = new L.Control.maxExtent();
      map.addControl(maxExtent);

      //******Bing geocoder control
      var tmpPoint = new L.marker;
      var bingGeocoder = new L.Control.BingGeocoder('At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn', { callback: function (results) {
                     var bbox = results.resourceSets[0].resources[0].bbox,
                            first = new L.LatLng(bbox[0], bbox[1]),
                            second = new L.LatLng(bbox[2], bbox[3]),
                            tmpBounds = new L.LatLngBounds([first, second]);
                     this._map.fitBounds(tmpBounds);
                     this._map.removeLayer(tmpPoint);
                     tmpPoint = new L.marker(results.resourceSets[0].resources[0].point.coordinates).bindPopup(results.resourceSets[0].resources[0].address.formattedAddress);
                     this._map.addLayer(tmpPoint);
                   }
      });

      map.addControl(bingGeocoder);

      //******Add basemaps
      var googleHybrid = new L.Google('HYBRID');
      var googleSatellite = new L.Google('SATELLITE');
      var googleStreet = new L.Google('ROADMAP');
      var googleTerrain = new L.Google('TERRAIN');
      var bingHybrid = new L.BingLayer("At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn", {type: 'AerialWithLabels'});
      var bingSatellite = new L.BingLayer("At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn", {type: 'Aerial'});
      var bingStreet = new L.BingLayer("At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn", {type: 'Road'});

      map.addLayer(googleHybrid);

      //******Add Geoserver Layers
      var gsHuc8 = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/crossings/wms", {
        layers: 'crossings:deerfield_huc8',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsTowns = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/crossings/wms", {
        layers: 'crossings:deerfield_towns',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsCounties = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/crossings/wms", {
        layers: 'crossings:deerfield_counties',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsDOTDistricts = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/crossings/wms", {
        layers: 'crossings:deerfield_dot_districts',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });


      //******Make d3 vector layers variable
      var topoSVG = d3.select(map.getPanes().overlayPane).append("svg");
      var catchG = topoSVG.append("g").attr("class", "leaflet-zoom-hide").attr("id", "catchG");
      var streamG = topoSVG.append("g").attr("class", "leaflet-zoom-hide").attr("id", "streamG");
      var crossG = topoSVG.append("g").attr("class", "leaflet-zoom-hide").attr("id", "crossG");


      //******Add and remove crossings topo layer
      var crossTogSVG = d3.select(map.getPanes().overlayPane).append("svg");

      crossTogSVG.onAdd = function(map) {
        addTopo(topos.crossings);
      }

      crossTogSVG.onRemove = function(map) {
        removeTopo(topos.crossings);
      }


      //******Add and remove catchments topo layer
      var catchTogSVG = d3.select(map.getPanes().overlayPane).append("svg");

      catchTogSVG.onAdd = function(map) {
        addTopo(topos.catchments);
      }

      catchTogSVG.onRemove = function(map) {
        removeTopo(topos.catchments);
      } 


      //******Add and remove streams topo layer
      var streamTogSVG = d3.select(map.getPanes().overlayPane).append("svg");
  
      streamTogSVG.onAdd = function(map) {
        addTopo(topos.streams);
       }

      streamTogSVG.onRemove = function(map) {
        removeTopo(topos.streams);
      }


      //******Add topo layer to map
      function addTopo(topo) {
        var tmpFeats = topo.g.selectAll("." + topo.class)
            .data(topo.features)
          .enter().append("path")
            .attr("d", path)
            .attr("class", topo.class)
            .on("mouseover", function(data) { showIt(this.id); })
            .on("mousemove", function() { return tooltip.style("top", (d3.event.pageY-10) + "px").style("left", (d3.event.pageX+10) + "px"); })
            .on("mouseout", function() { return tooltip.style("visibility", "hidden"); });
        changeStyle(d3.select("#" + topo.class + "Select").node().value, topo);
        filterMap("featureid", topo, true);
        d3.select("#" + topo.class + "Legend").style("display", "block");
      }


      //******Remove topo layer to map
      function removeTopo(topo) {
        var tmpFeats = topo.g.selectAll("." + topo.class);
        tmpFeats.remove();
        d3.select("#" + topo.class + "Legend").style("display", "none");
      }


      //******Add Geoserver Deerfield HUC8 layer to map
      map.addLayer(gsHuc8);

      //******Make layer controller
      var baseLayers = {"Google Hybrid": googleHybrid, "Google Satellite": googleSatellite, "Google Street": googleStreet, "Google Terrain": googleTerrain, "Bing Hybrid": bingHybrid, "Bing Satellite": bingSatellite, "Bing Street": bingStreet};
      var overlays = {"DOT Districts": gsDOTDistricts, "Counties": gsCounties, "Towns": gsTowns, "Deerfield Watershed": gsHuc8, "Catchments": catchTogSVG, "Streams": streamTogSVG, "Crossings": crossTogSVG};
      L.control.layers(baseLayers, overlays).addTo(map);

/*
      //******Make header div
      d3.select("body")
        .append("div")
        .attr("class", "header");
*/

      //******Make tooltip for displaying attribute data
      var tooltip = d3.select("body")
        .append("div")
        .attr("class", "d3Tooltip");



      //******Make div for legends
      d3.select("body")
        .append("div")
        .attr("class", "legend")
        .attr("id", "legendDiv");

      d3.select("#legendDiv")
        .append("h4")
        .text("Legends")
        .attr("class", "legTitle");

 

      //******Make divs for filters
      d3.select("body")
        .append("div")
        .attr("class", "legend")
        .attr("id", "filters");

      d3.select("#filters")
        .append("h4")
        .text("Filters")
        .attr("class", "legTitle");

      d3.select("#filters")
        .append("div")
        .attr("id", "filterLayers");

      //*******Add div for linking crossfilters
      d3.select("#filters")
        .append("hr")
        .attr("class", "hr");

      d3.select("#filters")
        .append("div")
        .attr("id", "linkLayers");

      //*******Add div for total selections
      d3.select("#filters")
        .append("div")
        .attr("id", "totals");

      //*******Add div for histograms
      d3.select("#filters")
        .append("div")
          .attr("id", "charts")





      //******Make color scale for streams
      var streamColor = d3.scale.quantize()
        .domain([1, 9])
        .range(colorbrewer.YlGnBu[9]);






      //******Make variables for d3 topoJSON and TSV data
      var topos = {};  //global topoJSON files variable
      var brush = {};   //global brush variable
      var hist = {};   //global histogram object variable
      var graphs = [];   //global list of current graphs variable
      var layers = [];   //global list of topoJSON map layers

      //******Add in custom color pallate for streams
      colorbrewer.streams = {};
      colorbrewer.streams["5"] = ["#081d58","#253494","#225ea8","#1d91c0","#41b6c4"];

      //******Wait for all topoJSON files to load
      queue()
        .defer(d3.json, 'streams_topo.json')
        .defer(d3.json, 'crossings_topo.json')
        .defer(d3.json, 'catchments_topo.json')
        .defer(d3.tsv, 'crossings_covariates.tsv')
        .defer(d3.tsv, 'catchments_covariates.tsv')
        .defer(d3.tsv, 'streams_covariates.tsv')
        .defer(d3.tsv, 'catchments_political.tsv')
        .await(displayIt);







      //******Bind topoJSON data
      function displayIt(error, streamData, crossingData, catchData, crossCov, catchCov, streamCov, political) {
        topos.crossings = topojson.feature(crossingData, crossingData.objects.Deerfield_barriers_merged_09_08_15_10M_snap_nodups_featureid_wgs84);
        topos.catchments = topojson.feature(catchData, catchData.objects.Deerfield_NHD_Hi_Res_Catchments_wgs84);
        topos.streams = topojson.feature(streamData, streamData.objects.edges_nodes_fbar_tbar_wgs84);

        //******Add properties to topos and push layer
        addProps("crossings", crossG, "unique_id", "RdYlBu");
        addProps("catchments", catchG, "featureid", "YlGn");
        addProps("streams", streamG, "unique_id", "streams");

        //******Add covatiate TSV files to topojson
        crossCov = readTSV(crossCov, topos.crossings);
        catchCov = readTSV(catchCov, topos.catchments);
        streamCov = readTSV(streamCov, topos.streams);
        
        //******Get keys for crossings and catchment properties
        topos.crossings.keys = d3.keys(crossCov[0]);
        topos.catchments.keys = d3.keys(catchCov[0]);
        topos.streams.keys = d3.keys(streamCov[0]);

        //******Read in political featureids
        topos.political = strToNum(political);

        //******Make crossfilter dimensions
        cfDimension(topos.crossings, crossCov);
        cfDimension(topos.catchments, catchCov);
        cfDimension(topos.streams, streamCov);

        //******Release covariate data
        crossCov = null;
        catchCov = null;
        streamCov = null;

        //******Set d3 map data
        bounds = d3.geo.bounds(topos.catchments);
        path = d3.geo.path()
                 .projection(projectPoint)
                 .pointRadius(3.5);

        //******Add drop down box to select crossing attribute for styling
        addLegend(topos.crossings);
        addLegend(topos.catchments);
        addLegend(topos.streams);

        //******Add drop down box to select attributes for filtering
        addFilterSelect(topos.crossings);
        addFilterSelect(topos.catchments);
        addFilterSelect(topos.streams);

        addCFLinks(layers);
        
        //******Add topoJSON layers
        map.addLayer(crossTogSVG);
        d3.select("#catchmentsSelect").property("selectedIndex", function() {return 1;});
        map.addLayer(catchTogSVG);
        map.addLayer(streamTogSVG);
       
        //******Set map view
        map.on("viewreset", reset);
        reset();
      }
      






      //******Add checkboxes to link crossfilters
      function addCFLinks(tmpLayers) {
        tmpLayers.forEach(function(layer1, i) {
          tmpLayers.forEach(function(layer2, j) {
            if (j > i) {
              d3.select("#linkLayers")
                .append("div")
                .attr("class", "linkLayers")
                .attr("id", layer1 + "-" + layer2 + "-link");

              d3.select("#" + layer1 + "-" + layer2 + "-link")
                .append("input")
                .attr({type: "checkbox", name: layer1 + "-" + layer2 + "-check"})
                .attr("id", layer1 + "-" + layer2 + "-check")
                .attr("class", "linkCheck")
                .property("checked", false)
                .on("click", function() { checkLink("featureid", layer1, true) });   //Layer1 doesn't matter, just a placeholder

              d3.select("#" + layer1 + "-" + layer2 + "-link")
                .append("label")
                .text("Link " + layer1 + " & " + layer2)
                .attr("class", "linkLabel")
                .attr("id", layer1 + "-" + layer2 + "-linkLabel");
            }
          });
        });
      }
     



      //******Add properties to topos and push layer
      function addProps(tmpName, tmpG, tmpID, tmpColor) {
        topos[tmpName].class = tmpName;
        topos[tmpName].g = tmpG;
        topos[tmpName].uniqueID = tmpID;
        topos[tmpName].covType = {};
        topos[tmpName].filter = {};
        topos[tmpName].binWidth = {};
        topos[tmpName].color = tmpColor;
        brush[tmpName] = {};
        hist[tmpName] = {};
        layers.push(tmpName);
      }







      function addFilterSelect(topo) {
        //******Add div for layer
        d3.select("#filterLayers")
          .append("div")
          .attr("class", "filterLayers")
          .attr("id", topo.class + "Filter");

        //******Add drop down box to select attribute for filtering
        d3.select("#" + topo.class + "Filter")
          .append("h5")
          .attr("id", topo.class + "FilterTitle")
          .attr("class", "filterTitle")
          .text(topo.class.charAt(0).toUpperCase() + topo.class.slice(1));

        var select = d3.select("#" + topo.class + "Filter")
          .append("select")
          .attr("class", "filterAttrList")
          .attr("id", topo.class + "FilterSelect")
          .on("change", function () { addFilter(this.value, topo); });

        var plusKeys = topo.keys;
        plusKeys.splice(0,0, "none");
        select.selectAll("option")
          .data(plusKeys)
          .enter().append("option")
          .attr("value", function (d, i) { return plusKeys[i]; })
          .text(function (d, i) { return plusKeys[i]; });

        d3.select("#totals")
          .append("div")
          .html('<span id="active-' + topo.class + '">' + topo.filter.all.value() + '</span> of <span id="total">' + topo.filter.all.value() + '</span> ' + topo.class + ' selected'); ;
      }






      function addLegend(topo) {
        d3.select("#legendDiv")
          .append("div")
          .attr("id", topo.class + "Legend");

        d3.select("#" + topo.class + "Legend")
          .append("hr")
          .attr("class", "hr");

        d3.select("#" + topo.class + "Legend")
          .append("h5")
          .text(topo.class.charAt(0).toUpperCase() + topo.class.slice(1))
          .attr("class", "layerTitle");

        var select = d3.select("#" + topo.class + "Legend")
          .append("select")
          .attr("class", "legAttrList")
          .attr("id", topo.class + "Select")
          .on("change", function () { changeStyle(this.value, topo); });

        select.selectAll("option")
          .data(topo.keys)
          .enter().append("option")
          .attr("value", function (d, i) { return topo.keys[i]; })
          .text(function (d, i) { return topo.keys[i]; });
      }







      //*****Reposition the SVG to cover the features.
      function reset() {
        //******Set bounds (using Deerfield HUC 8 bounds)
        var bottomLeft = projectPoint(bounds[0]);
        var topRight = projectPoint(bounds[1]);
          
        topoSVG.attr('width', topRight[0] - bottomLeft[0])
          .attr('height', bottomLeft[1] - topRight[1])
          .style('margin-left', bottomLeft[0] + 'px')
          .style('margin-top', topRight[1] + 'px');

        var translation = -bottomLeft[0] + ',' + -topRight[1];

        //******Select all layer g elements
        var tmpG = topoSVG.selectAll("g");

        //******Loop through each g element and transform the path
        tmpG[0].forEach(function(g) {
          var curG = d3.select(g);
          var feature = curG.selectAll("path");
          curG.attr('transform', 'translate(' + -bottomLeft[0] + ',' + -topRight[1] + ')');
          feature.attr("d", path);
        });  
      }






      //******Use Leaflet to implement a D3 geometric transformation.
      function projectPoint(x) {
        var point = map.latLngToLayerPoint(new L.LatLng(x[1], x[0]));
        return [point.x, point.y];
      }






      //******Change number strings to values
      function strToNum(tmpData) {
        var tmpKeys = d3.keys(tmpData[0]);
        var tmpCov = tmpData.map(function(d) {
          var tmpJSON = {};
          var tmpVals = d3.values(d);
          tmpVals.forEach(function(val,i){ 
            if (isNaN(val) == false) {
              tmpJSON[tmpKeys[i]] = +d[tmpKeys[i]];
            }
            else {
              tmpJSON[tmpKeys[i]] = d[tmpKeys[i]];
            }
          });
          return tmpJSON;
        });
        return tmpCov
      }



      //******Transform TSV strings to values if appropriate and add to topojson
      function readTSV(tmpData, topo) {
        //******Get keys and values from TSV data and fill out covariate data type
        var tmpKeys = d3.keys(tmpData[0]);
        var tmpVals = d3.values(tmpData[0]);

        tmpVals.forEach(function(val,i){
          if (isNaN(val) == false) {
            topo.covType[tmpKeys[i]] = "number";
          }
          else {
            topo.covType[tmpKeys[i]] = "string";
          }
        });

        //******Change TSV attribute strings to values if appropriate
        var tmpCov = strToNum(tmpData);

        //*******Map TSV to ID_key attribute (in this case either unique_id (crossings, streams) or featureid (catchments)
        var tmpMap = d3.map(tmpCov, function(d) {return d[topo.uniqueID];});

        //*******Add TSV data to topojson
        topo.features.forEach(function(d) { 
          try {
            tmpKeys.forEach(function(key) {
              d.properties[key] = tmpMap.get(d.id)[key];
            });
          }
          catch(err) { 
            console.log("No TSV data for id " + d.id);
          }
        });

        return tmpCov;
      }





      //*******Make crossfilter dimensions and grouped dimensions
      function cfDimension(topo, covariates) {
        //******Assign crossing covariates to a crossfilter variable

        var tmpCF = crossfilter(covariates);
        topo.filter.all = tmpCF.groupAll();
        topo.binWidth = {};

        //******Dimension and group each covariate
        topo.keys.forEach(function(key, i) {
          topo.filter[key] = tmpCF.dimension(function(d) { return d[key]; } );
          if (topo.covType[key] == "number") {
            var tmpTop = topo.filter[key].top(1);
            var tmpBot = topo.filter[key].bottom(1);
            var divVal = (tmpTop[0][key] - tmpBot[0][key]) / 40;
            topo.binWidth[key] = divVal;
            topo.filter[key + "s"] = topo.filter[key].group(function(d) {return Math.floor(d / divVal) * divVal;});
          }
          else {
            topo.filter[key + "s"] = topo.filter[key].group();
          }
        });
       }








      //*******Show crossings attribute in tooltip
      function showIt(tmpID) {
        tooltip.text(tmpID);
        tooltip.style("visibility", "visible");
      }






      //*******Change feature styles
      function changeStyle(tmpAtt, topo) {
        //*******Select features
        var curG = d3.select(topo.g[0][0]);
        var tmpFeat = curG.selectAll("." + topo.class);

        //*******Get data for passed in attribute
        var tmpVals = d3.values(topo.features).map(function(d) { return d.properties[tmpAtt]; });

        var tmpSet = d3.set(tmpVals);
        var tmpMin = d3.min([5, tmpSet.size()])

        //*******Make a color scale
        if (tmpMin > 2) {
          var newColor = d3.scale.quantize()
            .domain([d3.max([0,d3.min(tmpVals)]), d3.max(tmpVals)])
            .range(colorbrewer[topo.color][tmpMin]);
        }
        else {
          var newColor = d3.scale.quantize()
            .domain([1, 2])
            .range(["#d7191c", "#2c7bb6"]);
        }

        //*******Style and label crossings by attribute value
        if (topo.class == "streams") {
          tmpFeat.style("stroke", function(d) { return newColor(d.properties[tmpAtt]); });
        }
        else {
          tmpFeat.style("fill", function(d) {return newColor(d.properties[tmpAtt]); });
        }
        tmpFeat.attr("id", function(d) { return (tmpAtt + ": " + d.properties[tmpAtt]); })

        //*******Make a legend
        var list = d3.select("#" + topo.class + "-list-inline");
        list.remove();

        var legend = d3.select("#" + topo.class + "Legend")
         .append("ul")
         .attr("id", topo.class + "-list-inline")
         .attr("class", "legend-colors");

        var keys = legend.selectAll("li.key")
          .data(newColor.range());

        keys.enter().append("li")
          .attr("class", "key")
          .style("border-top-color", String)
          .text(function(d) {
            var r = newColor.invertExtent(d);
            return r[0].toFixed(1);
          });
       }






      //*******Add crossfilter histogram
      function addFilter(tmpKey, topo) {
        if (graphs.indexOf(topo.class + "-" + tmpKey) > -1) {
          return;
        }
        else if (tmpKey == "none") {
          var tmpGraphs = graphs.slice();
          tmpGraphs.forEach(function(d) {
            if (d.indexOf(topo.class) > -1) {
              removeFilter(d, topo);
            }
          });
          return;
        }
        else {
          graphs.push(topo.class + "-" + tmpKey);
        }

        //******Define graph attributes
        var margin = {top: 10, right: 10, bottom: 20, left: 10},
          width = 390 - margin.left - margin.right,
          height = 100 - margin.top - margin.bottom;

        var x = d3.scale.linear()
          .rangeRound([0, width]);

        var y = d3.scale.linear()
          .range([height, 0]);

        var xAxis = d3.svg.axis()
          .scale(x)
          .orient("bottom")
          .ticks(10);


        //******Add brush
        brush[topo.class][tmpKey] = d3.svg.brush()
          .x(x)
          .on("brushstart", function() { brushStart(tmpKey, topo); })
          .on("brush", function() { brushMove(tmpKey, topo); })
          .on("brushend", function() { brushEnd(tmpKey, topo); });


        //******Add chart div, title div, and reset option
        d3.select("#charts")
          .append("div")
            .attr("class", "chart")
            .attr("id", topo.class + "-" + tmpKey)
          .append("div")
            .attr("class", "title")
            .attr("id", "title-" + topo.class + "-" + tmpKey)
            .style("margin-left", "2px")
            .text(topo.class + ": " + tmpKey)
          .append("a")
            .attr("class", "reset")
            .text("reset")
            .on("click", function() { brushReset(tmpKey, topo); });


        //******Add remove button
        d3.select("#title-" + topo.class + "-" + tmpKey)
          .append("div")
            .attr("class", "btn btn-default btn-xs pull-right")
            .attr("title", topo.class + "-" + tmpKey)
            .text("x")
            .on("click", function() { removeFilter(this.title, topo); });


        //******Add stats div and extent
        d3.select("#" + topo.class + "-" + tmpKey)
          .append("div")
            .attr("class", "stats")
            .attr("id", "stats-" + topo.class + "-" + tmpKey)
          .append("span")
            .attr("class", "extent")
            .attr("id", "extent-" + topo.class + "-" + tmpKey);


        //******Add mean to stats div
        d3.select("#stats-" + topo.class + "-" + tmpKey)
          .append("span")
            .attr("class", "mean pull-right")
            .attr("id", "mean-" + topo.class + "-" + tmpKey);


        //******Add svg
        var svg = d3.select("#" + topo.class + "-" + tmpKey)
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .attr("id", "svg-" + topo.class + "-" + tmpKey)
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
            .attr("id", "g-" + topo.class + "-" + tmpKey);


        //******Get data and make graph
        var tmpData = topo.filter[tmpKey + "s"].all();

        x.domain([tmpData[0].key, tmpData[tmpData.length - 1].key + topo.binWidth[tmpKey]]);
        y.domain([0, d3.max(tmpData, function(d) { return d.value; })]);

        svg.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height + ")")
          .call(xAxis);

        var tmpData = topo.filter[tmpKey + "s"].all();
        hist[topo.class][tmpKey] = {"x": x, "y": y, "height": height, "width": width};
      
        svg.selectAll(".bar")
            .data(tmpData)
          .enter().append("rect")
            .attr("class", "foreground bar")
            .attr("x", function(d) { return x(d.key); })
            .attr("width", (x.range()[1] - x.range()[0])/40)  
            .attr("y", function(d) { return y(d.value); })
            .attr("height", function(d) { return height - y(d.value); });
      
        var gBrush = svg.append("g")
          .attr("class", "brush")
          .attr("id", "brush-" + topo.class + "-" + tmpKey)
          .call(brush[topo.class][tmpKey]);

        gBrush.selectAll("rect").attr("height", height);
        gBrush.selectAll(".resize").append("path").attr("d", resizePath);

        brushReset(tmpKey, topo);

        function resizePath(d) {
          var e = +(d == "e"),
            x = e ? 1 : -1,
            y = height / 3;
          return "M" + (0.5 * x) + "," + y + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6) + "V" + (2 * y - 6) + "A6,6 0 0 " + e + " " + (0.5 * x) + "," + (2 * y) + "Z" + "M" + (2.5 * x) + "," + (y + 8) + "V" + (2 * y - 8) + "M" + (4.5 * x) + "," + (y + 8) + "V" + (2 * y - 8);
        }
      }








      //******Remove graph from window
      function removeFilter(class_key, topo) {
        var dash = class_key.indexOf("-");
        var tmpClass = class_key.slice(0, dash);
        var key = class_key.slice(dash + 1, class_key.length);

        graphs.splice(graphs.indexOf(class_key), 1);
        brushReset(key, topo);
        var select = d3.select("#" + class_key);
        select.remove();
      }



      function brushStart(tmpKey, topo) {
       topo.filter[tmpKey].filterRange([brush[topo.class][tmpKey].extent()[0], brush[topo.class][tmpKey].extent()[1]]);
       checkLink(tmpKey, topo, false);
      }


      function brushMove(tmpKey, topo) {
        topo.filter[tmpKey].filterRange([brush[topo.class][tmpKey].extent()[0], brush[topo.class][tmpKey].extent()[1]]);
        checkLink(tmpKey, topo, false);
      }

      function brushEnd(tmpKey, topo) {
        topo.filter[tmpKey].filterRange([brush[topo.class][tmpKey].extent()[0], brush[topo.class][tmpKey].extent()[1]]);       
        checkLink(tmpKey, topo, false);
      }

      function brushReset(tmpKey, topo) {
        d3.select("#brush-" + topo.class + "-" + tmpKey).call(brush[topo.class][tmpKey].clear());
        topo.filter[tmpKey].filterAll();
        checkLink(tmpKey, topo, false);
        //redrawHist(tmpKey, topo);
      }

      function filterMap(tmpKey, topo, isLink) {
        var tmpSubset = topo.filter[topo.uniqueID].top(Infinity);
        var tmpID = tmpSubset.map(function(d) {return d[topo.uniqueID];});
        var tmpData = d3.selectAll("." + topo.class).data();
        var tmpSel = d3.selectAll("." + topo.class);
        tmpSel.style("opacity", function(d, i) { 
          if (tmpID.indexOf(tmpData[i].properties[topo.uniqueID]) > -1) {
            return 1;
          }
          else {
            return 0;
          }
        });

        //******Update crossings selected
        d3.select("#active-" + topo.class).html(topo.filter.all.value());

        //******Update filter range (if isLink == false)
        if (isLink == false) {
          if (brush[topo.class][tmpKey].empty() && topo.filter.all.value() > 0) {
            d3.select("#extent-" + topo.class + "-" + tmpKey).html(topo.filter[tmpKey].bottom(1)[0][tmpKey].toFixed(1) + " - " + topo.filter[tmpKey].top(1)[0][tmpKey].toFixed(1));
          }
          else {
            d3.select("#extent-" + topo.class + "-" + tmpKey).html(brush[topo.class][tmpKey].extent()[0].toFixed(1) + " - " + brush[topo.class][tmpKey].extent()[1].toFixed(1));
          }
        }

        updateStats(tmpKey, topo);

        updateHistogram(tmpKey, topo);
      }





      //******Set featureid according to which layers are linked
      function checkLink(tmpKey, topo, isLink) {
        //******Return array of layers that are linked
        var linkLayers, IDS = getLinkIDs();
              
        //******Filter the map based on common featureids
        layers.forEach(function(layer) {
          if (isLink == false && layer == topo.class) {
            filterMap(tmpKey, topos[layer], false);
          }
          else {
            filterMap("featureid", topos[layer], true);
          }
        });
      }




      //******Determine linked layers
      function getLinkIDs() {
        var linkLayers = [];

        layers.forEach(function(layer1, i) {
          layers.forEach(function(layer2, j) {
            if (j > i) {
              topos[layer1].filter.featureid.filterAll();
              topos[layer2].filter.featureid.filterAll();

              if (d3.select("#" + layer1 + "-" + layer2 + "-check").property("checked") == true) {
                if (linkLayers.indexOf(layer1) == -1) {
                  linkLayers.push(layer1);
                }
                if (linkLayers.indexOf(layer2) == -1) {
                  linkLayers.push(layer2);
                }
              }
            }
          });
        });

        var IDs = [];
        linkLayers.forEach(function(layer1, i) {
          var tmpSubset = topos[layer1].filter.featureid.top(Infinity);
          var tmpID1 = tmpSubset.map(function(d) {return d["featureid"];});
          linkLayers.forEach(function(layer2, j) {
            if (j > i) {
              var tmpSubset2 = topos[layer2].filter.featureid.top(Infinity);
              var tmpID2 = tmpSubset2.map(function(d) {return d["featureid"];});
              if (IDs.length == 0 && i == 0) {
                IDs = tmpID1.filter(function(val) {
                  return tmpID2.indexOf(val) != -1;
                });
              }
              else {
                var IDsFilter = IDs.filter(function(val) {
                  return (tmpID1.indexOf(val) != -1 && tmpID2.indexOf(val) != -1);
                });
                IDs = IDsFilter;
              }
            }
          });
        });

        linkLayers.forEach(function(layer) {
          topos[layer].filter.featureid.filterFunction(function(d) { 
            return IDs.indexOf(d) != -1;
          });
        });

        return linkLayers, IDs;
      }



      
      //******Update filter statistics
      function updateStats(tmpKey, topo) {
        //******Update filter mean
        graphs.forEach(function(class_key) {
          var dash = class_key.indexOf("-");
          var tmpClass = class_key.slice(0, dash);
          var key = class_key.slice(dash + 1, class_key.length);

          if (class_key.indexOf(topo.class) > -1) {
            if (topo.filter["all"].value() > 0 ) {
              d3.select("#mean-" + class_key).html("Mean: " + d3.mean(topo.filter[key].top(Infinity), function(d) { return d[key]; }).toFixed(1));       
            }
            else {
              d3.select("#mean-" + class_key).html("Mean: 0.0");
            }
          }  
        });
      }




      //******Update filter histogram based on current brush
      function updateHistogram(tmpKey, topo) {
        graphs.forEach(function(class_key) {
          var dash = class_key.indexOf("-");
          var tmpClass = class_key.slice(0, dash);
          var key = class_key.slice(dash + 1, class_key.length);

          if (class_key.indexOf(topo.class) > -1) { 
            if (class_key != topo.class + "-" + tmpKey) {
              redrawHist(key, topo);
            }
          }
        });
      }

      //******Redraw the histogram
      function redrawHist(key, topo) {
        //******If brush is present, remove it and get featureID's, then add it back
        if (!brush[topo.class][key].empty()) {
          topo.filter[key].filterAll();
          var linkLayers, IDs = getLinkIDs();
          console.log("Post-removal: " + topo.filter["all"].value());
          var tmpData = JSON.parse(JSON.stringify(topo.filter[key + "s"].all()));
          topo.filter[key].filterRange([brush[topo.class][key].extent()[0], brush[topo.class][key].extent()[1]]);
          var linkLayers, IDs = getLinkIDs();
        }
        else {
          var tmpData = topo.filter[key + "s"].all();
        }

        var svg = d3.select("#g-" + topo.class + "-" + key);
        var x = hist[topo.class][key].x;
        var y = hist[topo.class][key].y;
        var height = hist[topo.class][key].height;
        var width = hist[topo.class][key].width;
        y.domain([0, d3.max(tmpData, function(d) { return d.value; })]);

        var update = svg.selectAll(".bar")
          .data(tmpData);

        update.exit().remove();
        update.enter().insert("rect", ":first-child")
          .attr("class", "foreground bar");
        update
          .attr("x", function(d) { return x(d.key); })
          .attr("width", (x.range()[1] - x.range()[0])/40)  
          .attr("y", function(d) { return y(d.value); })
          .attr("height", function(d) { return height - y(d.value); });
      }


    </script>
  </body>
</html>